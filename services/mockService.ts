
import { Student, TuitionRecord, Course, DocumentFile, Exam } from '../types';
import { MOCK_COURSES } from '../constants';

const API_URL = 'http://localhost:4000/api';

// Helper for API calls with Error Handling
const apiCall = async (endpoint: string, method: string = 'GET', body?: any) => {
    try {
        const headers: HeadersInit = { 'Content-Type': 'application/json' };
        const config: RequestInit = { method, headers };
        
        if (body) {
            config.body = JSON.stringify(body);
        }
        
        const response = await fetch(`${API_URL}${endpoint}`, config);
        
        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.error || `API Error: ${response.status}`);
        }
        
        return await response.json();
    } catch (error) {
        console.error(`Error calling ${endpoint}:`, error);
        // Rethrow to let the UI handle the error (e.g. show toast)
        // Or return null if you want to fail silently
        throw error;
    }
};

export const initializeData = () => {
  // In a real Client-Server app, initialization happens on the server (Database migration).
  // We don't need to seed LocalStorage anymore.
  console.log("App initialized. Connecting to Backend at", API_URL);
};

export const studentService = {
  getAll: async (): Promise<Student[]> => {
    try {
        return await apiCall('/students');
    } catch (e) {
        console.warn("Backend not available, returning empty list.");
        return [];
    }
  },
  add: async (student: Student) => {
    // Remove ID if it's a temporary ID generated by frontend (e.g. starts with 'new_') 
    // or let Backend handle UUID generation if ID is not UUID.
    // However, our backend schema expects us to pass data.
    // If backend generates ID, we should send everything except ID if it's auto-generated.
    // For simplicity with our Prisma Schema which uses @default(uuid()), we can omit ID or send it if we want to force it.
    // Let's sanitize:
    const { id, ...rest } = student;
    return await apiCall('/students', 'POST', rest);
  },
  update: async (student: Student) => {
    const { id, ...rest } = student;
    return await apiCall(`/students/${id}`, 'PUT', rest);
  },
  delete: async (id: string) => {
    return await apiCall(`/students/${id}`, 'DELETE');
  }
};

export const tuitionService = {
  getAll: async (): Promise<TuitionRecord[]> => {
    try {
        return await apiCall('/tuition');
    } catch (e) {
        return [];
    }
  },
  update: async (record: TuitionRecord) => {
     // Our backend API handles the "Upsert" logic at POST /tuition
     const { id, ...rest } = record;
     // If it's a new record (frontend generated ID), send data without ID or with ID placeholder
     return await apiCall('/tuition', 'POST', record);
  }
};

export const examService = {
    getAll: async (): Promise<Exam[]> => {
        try {
             return await apiCall('/exams');
        } catch (e) {
            return [];
        }
    },
    add: async (exam: Exam) => {
        const { id, ...rest } = exam;
        return await apiCall('/exams', 'POST', rest);
    },
    update: async (exam: Exam) => {
        // We need to make sure 'questions' are included in the body
        return await apiCall(`/exams/${exam.id}`, 'PUT', exam);
    },
    delete: async (id: string) => {
        return await apiCall(`/exams/${id}`, 'DELETE');
    }
};

export const documentService = {
    getAll: async (): Promise<DocumentFile[]> => {
        try {
            return await apiCall('/documents');
        } catch (e) {
            return [];
        }
    },
    add: async (doc: DocumentFile) => {
        const { id, ...rest } = doc;
        return await apiCall('/documents', 'POST', rest);
    },
    update: async (doc: DocumentFile) => {
        return await apiCall(`/documents/${doc.id}`, 'PUT', doc);
    },
    delete: async (id: string) => {
        return await apiCall(`/documents/${id}`, 'DELETE');
    }
};

// Course Service (Keep mock for now or add backend endpoint if needed)
export const courseService = {
    getAll: async () => MOCK_COURSES
}
